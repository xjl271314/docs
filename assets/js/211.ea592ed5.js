(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{830:function(e,t,o){"use strict";o.r(t);var n=o(15),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"csrf-攻击"}},[e._v("CSRF 攻击")]),e._v(" "),o("p",[e._v("CSRF(Cross-site request forgery，跨站请求伪造)")]),e._v(" "),o("p",[e._v("CSRF 是借用了当前操作者的身份来偷偷完成了某个请求操作，而不是为了拿到用户信息。")]),e._v(" "),o("p",[e._v("攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。")]),e._v(" "),o("p",[e._v("CSRF 攻击攻击原理及过程如下：\n用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；")]),e._v(" "),o("p",[e._v("在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；")]),e._v(" "),o("p",[e._v("用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；")]),e._v(" "),o("p",[e._v("网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；")]),e._v(" "),o("p",[e._v("浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。")]),e._v(" "),o("p",[e._v("CSRF 漏洞检测：\n检测 CSRF 漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉 Referer 字段后再重新提交，如果该提交还有效，那么基本上可以确定存在 CSRF 漏洞。")]),e._v(" "),o("p",[e._v("防御 CSRF 攻击：\n目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。")]),e._v(" "),o("p",[e._v("验证 HTTP Referer 字段\n根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。")]),e._v(" "),o("p",[e._v("在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。")]),e._v(" "),o("p",[e._v("因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。")]),e._v(" "),o("p",[e._v("在请求地址中添加 token 并验证\nCSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。")]),e._v(" "),o("p",[e._v("可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。")]),e._v(" "),o("p",[e._v("在 HTTP 头中自定义属性并验证\n这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。")]),e._v(" "),o("p",[e._v("通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。")])])}),[],!1,null,null,null);t.default=r.exports}}]);